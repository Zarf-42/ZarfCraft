class_name ChunkManager extends Node

# This determines if we use infinite word generation size or finite.
@export var finite_world: bool = false
# This is used to determine the size of the world in meters, if Infinite World Generation isn't 
# turned on.
@export var world_vector: int = 128
@onready var chunk_size: int = Settings.chunk_size
@onready var skip_these_chunks = []
@export var world_size: Vector3 = Vector3(world_vector, world_vector, world_vector)

# Cutoff defines how dense the random cubes are. Higher numbers equate to less density.
@export_range(-1, 1) var cutoff: float = 0.1
@export var colors: Array[Color]
# We will get the random seed in the _ready() function.
@export var noise_seed: int = 0

var render_distance = Settings.chunk_render_distance
var random_generator = FastNoiseLite.new()
var number_of_chunks: Vector3

var loading_threads: Array = Settings.threads

var chunk_class = preload("res://chunk.tscn")

func _ready():
	# This makes it so the Signal emission at the end of generate_chunks() doesn't fire until the
	# World script is loaded. If we don't have these lines, that signal emits before the connection
	# is made in World's script.
	await $"../".ready
	
	var chunks_to_generate = []
	
	if finite_world == true:
		chunks_to_generate = generate_terrain_finite()
	else:
		chunks_to_generate = generate_terrain_infinite()
	
	multithreaded_terrain_generation(chunks_to_generate, loading_threads)

func generate_terrain_finite():
	random_generator.noise_type = FastNoiseLite.TYPE_SIMPLEX
	random_generator.frequency = 0.003
	number_of_chunks = world_size / chunk_size
	
	#generate_chunks(Vector3(0,0,0))

func generate_terrain_infinite():
	random_generator.noise_type = FastNoiseLite.TYPE_SIMPLEX
	random_generator.frequency = 0.003

	var chunk_queue = []
	chunk_queue.append_array(get_chunk_queue())
	# Right now, chunk_queue contains every chunk's coordinates. This needs to go to the
	# multithreaded_terrain_generation function.

	# This function should rapidly skip every chunk that already exists. As we are currently generating
	# a new world each time we run the game, this needs to be ignored. However, when we are able to
	# load a world from disk, we must use this.
	#skip_these_chunks.append(chunk_queue)
	
	# Get the number of threads available...
	var number_of_threads: int = loading_threads.size()
	
	# This takes the number of chunks in the queue and figures out how many each thread will take.
	var chunks_organized_into_threads = split_chunk_queue(chunk_queue, number_of_threads)
	# This establishes chunk_coordinates as a multi-dimensional array.
	var chunk_coordinates: Array = [[]]
	for thread in number_of_threads:
		# This appends blank arrays into chunk_coordinates, one for each available thread.
		chunk_coordinates.append([])
		for chunk in chunks_organized_into_threads[thread]:
			chunk_coordinates[thread].append(chunk_queue[chunk])

	return(chunk_coordinates)

#2/2/2026: Generates concentric circlular rings, not a spiral. Appears to have no gaps or overlap.
# This was largely generated by AI. Refactor using real human brains.
func get_chunk_queue():
	print("--Getting chunk queue...--")
	print("Render distance: ", render_distance)
	
	var chunk_queue = []
	
	for distance in range(1, render_distance + 1):
		# Generate all chunks within this ring (distance-1 < r <= distance)
		for x in range(-distance, distance + 1):
			for y in range(-distance, distance + 1):
				# Currently, we check for Z, which I think is altitude despite not being
				# altitude elsewhere. I think we should just skip Z check here and do altitude-based
				# generation within each chunk's generation.
				for z in range(0, 3):
					if x == 0 and y == 0:
						continue
				
					# Check if this chunk is in the current ring
					var current_ring = Vector3i(x, y, z).length()
					
					if current_ring > (distance - 1) and current_ring <= distance:
						chunk_queue.append(Vector3i(x, y, z))
	return(chunk_queue)

# First, this checks the chunk to see if it needs to be skipped. If not, it goes to add_chunk_to_screen().
#func generate_a_chunk(x, y, z):
	#var position = Vector3i(x, y, z)
	#if skip_these_chunks.has(position):
		#print("Skipping existing chunk at ", position)
		#return

	# Generate the chunk otherwise. This function defines each chunk's properties before putting it onscreen.
	# This is also where we need to hook in to generate terrain per chunk.
	#else:
		#pass
		# This needs to be whatever function actually adds a chunk to the worldspace.
		# add_chunk_to_screen(x, y)

func split_chunk_queue(jobs_in_queue, number_of_threads):
	var queues: Array = []
	
	# Create an empty array per thread (I'll call this "N" in the comments):
	for thread in number_of_threads:
		queues.append([])
	
	# Queues is now N empty arrays waiting to be filled with chunk indices.
	# I'm calling these empty arrays "lists". So Queue 0 List 604 would be the 605th chunk in the
	# first list. Nice and clear! >:(
	# Anyway, Dean Black suggested using Modulo division for this and it works really nicely!
	for job in jobs_in_queue.size():
		var list = job % number_of_threads
		queues[list].append(job)
	# Uncomment this Print to see how nicely these chunks get divvied up into threads.
	# print(queues)
	
	# At this point, "queues" is N lists of numbers, which represent chunk indices.
	# Thread 0 = [0, 14, 28...] Thread 1 = [1, 15, 29], etc.
	# Now we need to assign each index a Vector3 of coordinates, so we can ship each one off to the 
	# circular chunk generator function. But first, back to _ready().
	return(queues)

func generate_chunks(position):
	# 2/12/2026: Begain reriting this function. It expects a finite, square-shaped world. It needs
	# to work in a circular, infinite world with no known amount of chunks.
	
	var chunks = position.size()
	var i = 0
	for chunk in position:
		print("Chunk %s: %s" %[i, chunk])
		var new_chunk = chunk_class.instantiate()
		new_chunk.position = Vector3((chunk[0] * chunk_size), (chunk[2] * chunk_size), (chunk[1] * chunk_size))
		new_chunk.generate_data(chunk_size, 64, random_generator, colors)
		new_chunk.generate_mesh()
		call_deferred("add_child", new_chunk)
		i +=1
		
	
	# I do not know why we are dividing by 2. It was in the tutorial.
	#var chunks: Vector3 = number_of_chunks / 2
	#print("Chunks: ", number_of_chunks)
	#for x in range(number_of_chunks.x):
		#for z in range(number_of_chunks.z):
			#for y in range(number_of_chunks.y):
				#var new_chunk = chunk_class.instantiate()
				#new_chunk.position = Vector3(x, y, z) * chunk_size + position
				#new_chunk.generate_data(chunk_size, random_generator, colors)
				#new_chunk.generate_mesh()
				#print("New chunk placed at ", new_chunk.position)
				#call_deferred("add_child", new_chunk)

# The Following was from the tutorial, and only works for finite terrain gen. Removed 2/10/26.
#func generate_chunks(position: Vector3):
	#var chunks: Vector3 = number_of_chunks / 2
	#for x in range(number_of_chunks.x):
		#for z in range(number_of_chunks.z):
			#for y in range(number_of_chunks.y):
				#var new_chunk = chunk_class.instantiate()
				#new_chunk.position = Vector3(x, y, z) * chunk_size + position
				#add_child(new_chunk)
				#new_chunk.generate_data(chunk_size, world_size.y, random_generator, colors)
				#new_chunk.generate_mesh()
				## I thought this is where we'd want to call the Player Spawn function, but this
				## doesn't actually place the chunk in the world. Looking for the terrain's altitude
				## from here returns 0.0 because there is no terrain in the world yet.
				## Instead, we'll call it from chunk.gd, under commit_mesh().

func multithreaded_terrain_generation(chunks, number_of_threads):
	# "chunks" is a multidimensional array. The first dimension is one array for each thread. The
	# second is a list of Vector3is for each chunk.
	
	var i = 0
	for thread in number_of_threads.size():
		#loading_threads[thread].start(generate_chunks.bind(chunks[i]))
		loading_threads[thread].start(func(): generate_chunks(chunks[i]))
		i +=1


func _exit_tree():
	for thread in loading_threads:
		thread.wait_to_finish()
